/* 
Program 1 : Demonstration of class.
		A class is defined as template or model for an object. A class is collection
	     of varibles and functions. An object is defined as an instance of the class.
	     class is a reserved word. When we define a class, no memory is allocated to
	     the class.
*/

#include <iostream.h>
#include <conio.h>	// getch()

/*
class c1
{
private:
	int x, y, z;
public:
	void getdata()
	{
		cout << "\nEnter any 3 integers\n";
		cin >> x >> y >> z;
	}
	void add(c1 obj1, c1 obj2)
	{
		x = obj1.x + (&obj2)->x;
		this->y = obj1.y + obj2.y;
		(*this).z = obj1.z + obj2.z;
	}
	void putdata()
	{
		cout << x << "\t" << this->y << "\t" << (*this).z << endl;
	}
};
*/

class c1
{
private:
	int x, y, z;
public:
	void getdata();
	void add(c1 obj1, c1 obj2);
	void putdata();
};

void c1::getdata()
{
	cout << "\nEnter any 3 integers\n";
	cin >> x >> y >> z;
}

void c1::add(c1 obj1, c1 obj2)
{
	x = obj1.x + (&obj2)->x;
	this->y = obj1.y + obj2.y;
	(*this).z = obj1.z + obj2.z;
}

void c1::putdata()
{
	cout << x << "\t" << this->y << "\t" << (*this).z << endl;
}

void main()
{
	c1 obj1, obj2, obj3;

	obj1.getdata();
	obj2.getdata();

	obj3.add(obj1, obj2);
	
	cout << endl;
	obj1.putdata();
	obj2.putdata();

	cout << endl;
	obj3.putdata();

	cout << endl;
	getch();
}
Output :

Enter any 3 integers
10 20 30

Enter any 3 integers
25 36 14

10      20      30
25      36      14

35      56      44

Press any key to continue

/*
Program 2 : Write a C++ program for a triangle class. It contains 3 sides of a
	    triangle, functions like getdata() for accepting the 3 sides, test() function to 
	    test whether the 3 sides forms a triangle or not, area() function to find area, 
	    perimeter() function to find perimeter.
*/

#include <iostream.h>
#include <math.h>
#include <conio.h>		// getch()
#include <process.h>	// exit(0)

class triangle
{
private:
	float a, b, c;
public:
	void getdata()
	{
		cout << "\nEnter 3 sides of a triangle\n";
		cin >> a >> b >> c;
		test();
	}
	void test()
	{
		if( ((a+b)>c) && ((b+c)>a) && ((c+a)>b))
			cout << "\nGiven 3 sides can form a triangle" << endl;
		else
		{
			cout << "\nThe given 3 sides do not form a triangle" << endl;
			exit(0);
		}
	}

	float area()
	{
		float s;
		s = (a+b+c)/2;
		return (sqrt(s*(s-a)*(s-b)*(s-c)));
	}

	float perimeter()
	{
		return (a+b+c);
	}
};	// class must end with semicolon(;)

main()
{
	triangle t;
	t.getdata();
	
	float ans1, ans2;
	ans1 = t.area();
	ans2 = t.perimeter();

	cout << "\nArea is :  " << ans1 << endl;
	cout << "Perimeter is :  " << ans2 << endl;

	cout << endl;
	getch();
	return (0);
}

Output :

Enter 3 sides of a triangle
1
2
3

The given 3 sides do not form a triangle
Press any key to continue

Enter 3 sides of a triangle
2
3
4

Given 3 sides can form a triangle

Area is :  2.90474
Perimeter is :  9
Press any key to continue


/*
Program 3 : Assignment
		Write a C++ program for a rectangle class. It contains length, breadth,
	    getdata(), area(), perimeter().
*/

#include <iostream.h>
#include <conio.h>

class rectangle
{
private:
	int length, breadth;
public:
	void getdata();
	void area();
	void perimeter();
};

void rectangle::getdata()
{
	cout << "\nEnter the length and breadth of the rectangle\n";
	cin >> length >> this->breadth;
}

void rectangle::area()
{
	cout << "\nThe area of rectangle is :  " <<  length*breadth << endl;
}

void rectangle::perimeter()
{
	cout << "\nThe perimeter of rectangle is :  " << 2*(length+breadth) << endl;
}

main()
{
	rectangle t;
	t.getdata();
	t.area();
	t.perimeter();

	getch();

}

Output :

Enter the length and breadth of the rectangle
25
15

The area of rectangle is :  375

The perimeter of rectangle is :  80
Press any key to continue

/* 
Program 4 : Assignment
	         Write a C++ Program for student class. It contains roll no., student name, marks             of 3 subjects, total, average, grade. Functions like getdata(),compute(),putdata().
*/

#include <iostream.h>
#include <string.h>

class student
{
private:
	int rno;
	char sname[20];
	int marks[3];
	int total;
	float average;
	char grade[20];

public:
	void getdata();
	void compute();
	void putdata();
};

void student::getdata()
{
	cout << "\nEnter roll number : ";
	cin >> rno;
	cout << "\nEnter student name : ";
	cin.get();	// fflush(stdin) in c;
	cin.getline(sname, 20 , '\n');
	cout << "\nEnter marks of 3 subjects\n";
	cin >> marks[0] >> marks[1] >> marks[2];
}

void student::compute()
{
	this->total = marks[0] + (*this).marks[1] + this->marks[2];
	this->average = total/3.0;

	if(marks[0]<40 || marks[1]<40 || marks[2]<40)
		strcpy(this->grade, "Fail");
	else if(average >= 70)
		strcpy(grade, "Distinction");
	else if(average >=60)
		strcpy(grade, "First class");
	else if(average >= 50)
		strcpy(grade, "Second class");
	else
		strcpy(grade, "Third class");
}

void student::putdata()
{
	cout << "\nTotal marks   = " << total;
	cout << "\nAverage marks = " << average;
	cout << "\nGrade         = " << grade << endl;
}

main()
{
	student t;
	t.getdata();
	t.compute();
	t.putdata();

	cout << endl;
}
Output :

Enter roll number : 393542
Enter student name : palani kumar

Enter marks of 3 subjects
99 85 100

Total marks   = 284
Average marks = 94.6667
Grade         = Distinction

Press any key to continue

/* Program 5 : Assignment
		    Write a C++ program for an employee class. It contains employee
		number, employee name, salary, city, gross pay, net pay. Functions
		like getdata(), compute(), putdata()
*/

#include <iostream.h>
#include <string.h>

class emp
{
private:
	int empno;
	char ename[20];
	float sal;
	char city[20];
	float grosspay, netpay;
public:
	void getdata();
	void compute();
	void putdata();
};

void emp::getdata()
{
	cout << "\nEnter employee number :  ";
	cin >> this->empno;
	
	cout << "\nEnter employee name :  ";
	cin.get();
	cin.getline(this->ename, 20, '\n');

	cout << "\nEnter salary :  ";
	cin >> sal;
	cout << "\nEnter city name :  ";
	cin.get();
	cin.getline(city, 20);
}

void emp::compute()
{
	float da, hra, tax, pf, cca;
	/*
		da  -> dearness allowance
		hra -> house rent allowance
		pf  -> provident fund
		cca -> city compensation allowance
	*/
	da  = 0.5*sal;	// da is 50% of salary
	hra = 0.2*sal;	// hra is 20% of salary
	if(stricmp(city, "Hyderabad") == 0)
		cca = 100;
	else
		cca = 80;
	this->grosspay = this->sal+da+hra+cca;
	pf = (8.88/100)*grosspay;	// pf is 8.88% of grosspay
	if(grosspay < 10000)
		tax = grosspay*0.10;	// tax is 10% of grosspay
	else
		tax = grosspay*0.15;

	netpay = grosspay - pf -tax;
}

void emp::putdata()
{
	cout << "\nGross pay = " << this->grosspay;
	cout << "\nNet pay   = " << netpay << endl;
}

void main()
{
	emp a;
	a.getdata();
	a.compute();
	a.putdata();

	cout << endl;
}
Output :

Enter employee number :  1001

Enter employee name :  Palani Kumar

Enter salary :  25000

Enter city name :  Bangalore

Gross pay = 42580
Net pay   = 32411.9

Press any key to continue

/* 
Program 6 : Assignment
		Write a C++ program for a complex number class. It contains real
	    part, imaginary part, getdata(), putdata(), add(), sub(), mul(), div() 
*/

#include <iostream.h>

class complex
{
private:
	float rp, ip;
public:
	void getdata();
	void putdata();

	void add(complex a, complex b);
	void sub(complex a, complex b);
	void mul(complex a, complex b);
	void div(complex a, complex b);
};

inline void complex::getdata()
{
	cout << "\nEnter the real part and imaginary part of a complex number : \n";
	// cin >> rp >> ip;
	// cin >> this->rp >> this->ip;
	cin >> (*this).rp >> (*this).ip;
}

inline void complex::putdata()
{
	(ip < 0)?(cout << rp << " - " << (-ip) << "i") : (cout << rp << " + " << ip << "i");
	cout << endl;
}

inline void complex::add(complex a, complex b)
{
	rp = a.rp + b.rp;
	ip = a.ip + b.ip;
}

inline void complex::sub(complex a, complex b)
{
	rp = a.rp - b.rp;
	ip = a.ip - b.ip;
}

inline void complex::mul(complex a, complex b)
{
	rp = a.rp*b.rp - a.ip*b.ip; 
	ip = a.rp*b.ip + a.ip*b.rp;
}

inline void complex::div(complex a, complex b)
{
	rp = (a.rp*b.rp + a.ip*b.ip)/(b.rp*b.rp + b.ip*b.ip);
	ip = (a.ip*b.rp - a.rp*b.ip)/(b.rp*b.rp + b.ip*b.ip);
}

void main()
{
	complex a, b, c, d, e, f;	// 6 objects
	
	a.getdata();
	b.getdata();
	
	c.add(a, b);
	d.sub(a, b);
	e.mul(a, b);
	f.div(a, b);

	cout << endl << "The entered two complex numbers are as follows\n";
	a.putdata();
	b.putdata();

	cout << "\nAddition of two complex numbers" << endl;
	c.putdata();

	cout << "\nSubtraction of two complex numbers" << endl;
	d.putdata();

	cout << "\nMultiplication of two complex numbers" << endl;
	e.putdata();

	cout << "\nDivision of two complex numbers" << endl;
	f.putdata();

	cout << endl;
}

Output :

Enter the real part and imaginary part of a complex number :
3
4

Enter the real part and imaginary part of a complex number :
5
6

The entered two complex numbers are as follows
3 + 4i
5 + 6i

Addition of two complex numbers
8 + 10i

Subtraction of two complex numbers
-2 - 2i

Multiplication of two complex numbers
-9 + 38i

Division of two complex numbers
0.639344 + 0.0327869i

Press any key to continue

/* 
Program 7 : Assignment
		Write a C++ program for a rational number class. It contains 
	    numerator, denominator, getdata(), putdata(), add(), sub(), mul(), div() 
*/

#include <iostream.h>
#include <math.h>

class rational
{
private:
	int nr, dr;
public:
	void getdata()
	{
		cout << "\nEnter the numerator and denominator of a rational number : " << endl;
		cin >> nr >> dr;
		// cin >> this->nr >> this->dr;
		// cin >> (*this).nr >> (*this).dr;

		while(dr == 0)
		{
			cout << "\nDenominator can not be zero. Please re-enter : " << endl;
			cin >> dr;
		}
	}
	void putdata()
	{
		int ans;
		
		int GCD(int, int);		// function prototype
		ans = GCD(abs(nr), dr);
		
		nr = nr/ans;
		dr = dr/ans;

		cout << nr << " / " << dr << endl;
	}
	void add(rational a, rational b)
	{
		nr = a.nr*b.dr + a.dr*b.nr;
		dr = a.dr*b.dr;
	}
	void sub(rational a, rational b)
	{
		nr = a.nr*b.dr - a.dr*b.nr;
		dr = a.dr*b.dr;
	}
	void mul(rational a, rational b)
	{
		nr = a.nr*b.nr;
		dr = a.dr*b.dr;
	}
	void div(rational a, rational b)
	{
		nr = a.nr*b.dr;
		dr = a.dr*b.nr;
	}
	

};

// Global function
int GCD(int dividend, int divisor)
{
	int rem = dividend % divisor;
	while(rem != 0)
	{
		dividend = divisor;
		divisor = rem;
		rem = dividend % divisor;
	}
	return divisor;
}

void main()
{
	rational a, b, c, d, e, f;
	cout << "\nAccepting the first rational number :";
	a.getdata();
	cout << "\nAccepting the second rational number :";
	b.getdata();

	c.add(a, b);
	d.sub(a, b);
	e.mul(a, b);
	f.div(a, b);

	cout << "\nThe given two rational numbers are :" << endl;
	a.putdata();
	b.putdata();

	cout << "\nAddition of given two rational numbers : " << endl;
	c.putdata();

	cout << "\nSubtraction of given two rational numbers : " << endl;
	d.putdata();

	cout << "\nMultiplication of given two rational numbers : " << endl;
	e.putdata();

	cout << "\nDivision of given two rational numbers : " << endl;
	f.putdata();

	cout << endl;
}

Output :

Accepting the first rational number :
Enter the numerator and denominator of a rational number :
3
0

Denominator can not be zero. Please re-enter :
4

Accepting the second rational number :
Enter the numerator and denominator of a rational number :
5
6

The given two rational numbers are :
3 / 4
5 / 6

Addition of given two rational numbers :
19 / 12

Subtraction of given two rational numbers :
-1 / 12

Multiplication of given two rational numbers :
5 / 8

Division of given two rational numbers :
9 / 10

Press any key to continue

/*
Program 8 :	Write a C++ program for a stack class. It contains :
	     Array s, variable top, push(), pop(), display(), initialize().
	   Note : stack is nothing but LIFO(Last In First Out).
	   When the stack is empty, top = -1
	   When the stack is full, top = size-1
	   When top < (size-1), the stack is not full, insertion is possible. Both insertion
		and deletion is possible only from top.
*/

#include <iostream.h>
/*
	#include <iostream>
	using namespace std;
*/

#define size 10			// defining macro
// const int size = 10;

class stack
{
private:
	int s[size];
	int top;
public:
	void initialize();
	void push(int x);
	int pop();
	void display();
};

void stack::initialize()
{
	this->top = -1;
}

// insertion of value
void stack::push(int x)
{
	if(top == size-1)
		cout << "\nstack is full. Insertion is not possible" << endl;
	else
	{
		top++;
		s[top] = x;
	}
}

// popping (removing) the element from the stack
int stack::pop()
{
	if(top == -1)
		return -1;
	else
	{
		int x = s[top];
		top--;
		return x;
	}
}

// Displaying the stack elements
void stack::display()
{
	if(top == -1)
		cout << "\nstack is empty" << endl;
	else
	{
		for(int i=top; i>=0; i--)
			cout << s[i] << "\n";
	}
}

// Global function. Since menu() is non-member function, private variables of stack class
// are not accessed.
void menu()
{
	cout << "\n1. Insertion";
	cout << "\n2. Deletion";
	cout << "\n3. Display stack contents";
	cout << "\n4. Exit";
}

main()
{
	stack a;
	int ch, x;

	a.initialize();
	menu();
	cout << "\nEnter your choice :  ";
	cin >> ch;

	while(ch < 4)
	{
		switch(ch)
		{
		case 1:		// Insertion
			{
				cout << "\nEnter the value to be inserted :  ";
				cin >> x;
				a.push(x);
				break;
			}
		case 2:		// Deletion i.e., poping the element from the stack
			{
				int ret = a.pop();
				if(ret == -1)
					cout << "\nStack is empty. Deletion is not possible" << endl;
				else
					cout << "\nDeleted element is " << ret << endl;
				break;
			}
		case 3:		// Displaying the stack contents
			{
				a.display();
				break;
			}
		default:
			cout << "\nInvalid choice" << endl;
			break;
		}	// switch match

		menu();
		cout << "\nEnter your choice :  ";
		cin >> ch;
	}	//while match

	return (0);
}

Output :

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  1

Enter the value to be inserted :  15

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  1

Enter the value to be inserted :  20

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3
20
15

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  1

Enter the value to be inserted :  25

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3
25
20
15

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  1

Enter the value to be inserted :  -30

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3
-30
25
20
15

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  2

Deleted element is -30

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3
25
20
15

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  2

Deleted element is 25

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3
20
15

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  2

Deleted element is 20

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  2

Deleted element is 15

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3

stack is empty

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  1

Enter the value to be inserted :  250

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3
250

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  4
Press any key to continue

/* 
Program 9 : Write a C++ program for a generic stack class.
*/

#include <iostream.h>
#include <typeinfo.h>

#define size 10
// const int size = 10;

template <class T>
class stack
{
private:
	T s[size];
	int top;
public:
	void initialize();
	void push(T x);
	T pop();
	void display();
};
/*
	Note : The above class is called Generic class since the private variable s, is of
type T. Thus the difference between generic function and generic class is that in generic
function, atleast one parameter is of type T. In generic class, atleast one class variable
is of type T.
*/

template<class T>
void stack<T>::initialize()
{
	top = -1;
}

template<class T>
void stack<T>::push(T x)
{
	if(top == size-1)
		cout << "\nStack is full. Insertion is not possible. " << endl;
	else
	{
		top++;
		s[top] = x;
	}
}

template<class T>
T stack<T>::pop()
{
	T x;
	if(top == -1)
		return -1;
	else
	{
		x = s[top];
		top--;
		return (x);
	}
}

template <class T>
void stack<T>::display()
{
	if(top == -1)
		cout << "\nStack is Emtpy." << endl;
	else
	{
		cout << "\nThe following are the stack contents. " << endl;
		for(int i=top; i>=0; i--)
			cout << s[i] << endl;
	}
}

void menu1()
{
	cout << "\n1. Integer Stack";
	cout << "\n2. Float Stack";
	cout << "\n3. Character Stack";
	cout << "\n4. Exit";
}

void menu2()
{
	cout << "\n1. Insertion";
	cout << "\n2. Deletion";
	cout << "\n3. Display stack contents";
	cout << "\n4. Exit";
}

template <class T>
void operation(stack<T> a)
{
	int ch;
	T x;
	menu2();
	cout << "\nEnter your choice :  ";
	cin >> ch;

	a.initialize();
	while(ch < 4)
	{
		switch(ch)
		{
		case 1:		// Insertion
			{
				if(typeid(x) == typeid(int))
					cout << "\nEnter the integer value to be inserted :  ";
				else if(typeid(x) == typeid(float))
					cout << "\nEnter the float value to be inserted :  ";
				else if(typeid(x) == typeid(char))
					cout << "\nEnter the character to be inserted :  ";

				cin >> x;
				a.push(x);
				break;
			}
		case 2:		// Deletion i.e., poping the element from the stack
			{
				T ret = a.pop();
				if(ret == -1)
					cout << "\nStack is empty. Deletion is not possible" << endl;
				else
					cout << "\nDeleted element is " << ret << endl;
				break;
			}
		case 3:		// Displaying the stack contents
			{
				a.display();
				break;
			}
		default:
			cout << "\nInvalid choice" << endl;
			break;
		}	// switch match

		menu2();
		cout << "\nEnter your choice :  ";
		cin >> ch;
	}	//while match
}	// operation() match

void main()
{
	int ch;
	
	menu1();
	cout << "\nEnter your choice :  ";
	cin >> ch;

	while(ch < 4)
	{
		switch(ch)
		{
			case 1:
				{
					stack<int> a;
					a.initialize();
					operation(a);
					break;
				}
			case 2:
				{
					stack<float> a;
					a.initialize();
					operation(a);
					break;
				}
			case 3:
				{
					stack<char> a;
					a.initialize();
					operation(a);
					break;
				}
			default:
				{
					cout << "\nInvalid choice" << endl;
					break;
				}
		}	// switch match

		menu1();
		cout << "\nEnter your choice :  ";
		cin >> ch;
	}	// while match

	int x = 10;
	float y = 15.2532;
	char z = 'p';
	cout << "int x: typeid(x).name() = " << typeid(x).name() << " typeid(int).name() = " << typeid(int).name() << endl;
	cout << "float y: typeid(y).name() = " << typeid(y).name() << " typeid(float).name() = " << typeid(float).name() << endl;
	cout << "char z: typeid(z).name() = " << typeid(z).name() << " typeid(char).name() = " << typeid(char).name() << endl;
}	// main() match

/***
*typeinfo.h - Defines the type_info structure and exceptions used for RTTI
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the type_info structure and exceptions used for
*       Runtime Type Identification.
*
*       [Public]
*
****/

/*

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef __cplusplus
#error This header requires a C++ compiler ...
#endif

#ifndef _INC_TYPEINFO
#define _INC_TYPEINFO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* Define _CRTIMP */
/*

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
/*
#define _CRTIMP
#endif  /* _DLL */
/*#endif  /* _CRTIMP */
/*
class type_info {
public:
    _CRTIMP virtual ~type_info();
    _CRTIMP int operator==(const type_info& rhs) const;
    _CRTIMP int operator!=(const type_info& rhs) const;
    _CRTIMP int before(const type_info& rhs) const;
    _CRTIMP const char* name() const;
    _CRTIMP const char* raw_name() const;
private:
    void *_m_data;
    char _m_d_name[1];
    type_info(const type_info& rhs);
    type_info& operator=(const type_info& rhs);
};


// This include must occur below the definition of class type_info
#include <stdexcpt.h>

class _CRTIMP bad_cast : public exception {
public:
    bad_cast(const char * _Message = "bad cast");
    bad_cast(const bad_cast &);
    virtual ~bad_cast();
};

class _CRTIMP bad_typeid : public exception {
public:
    bad_typeid(const char * _Message = "bad typeid");
    bad_typeid(const bad_typeid &);
    virtual ~bad_typeid();
};

class _CRTIMP __non_rtti_object : public bad_typeid {
public:
    __non_rtti_object(const char * _Message);
    __non_rtti_object(const __non_rtti_object &);
    virtual ~__non_rtti_object();
};

#ifdef  __RTTI_OLDNAMES
// Some synonyms for folks using older standard
typedef type_info Type_info;
typedef bad_cast Bad_cast;
typedef bad_typeid Bad_typeid;
#endif  // __RTTI_OLDNAMES


#endif  // _INC_TYPEINFO


*/

Output :

1. Integer Stack
2. Float Stack
3. Character Stack
4. Exit
Enter your choice :  1

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  1

Enter the integer value to be inserted :  15

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  1

Enter the integer value to be inserted :  95

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3

The following are the stack contents.
95
15

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  2

Deleted element is 95

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3

The following are the stack contents.
15

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  2

Deleted element is 15

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3

Stack is Emtpy.

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  4

1. Integer Stack
2. Float Stack
3. Character Stack
4. Exit
Enter your choice :  3

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  1

Enter the character to be inserted :  t

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  1

Enter the character to be inserted :  p

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  1

Enter the character to be inserted :  k

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3

The following are the stack contents.
k
p
t

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  2

Deleted element is k

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  2

Deleted element is p

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3

The following are the stack contents.
t

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  2

Deleted element is t

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3

Stack is Emtpy.

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  4

1. Integer Stack
2. Float Stack
3. Character Stack
4. Exit
Enter your choice :  2

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  1

Enter the float value to be inserted :  25.625

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  1

Enter the float value to be inserted :  95.251

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3

The following are the stack contents.
95.251
25.625

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  2

Deleted element is 95.251

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  2

Deleted element is 25.625

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  3

Stack is Emtpy.

1. Insertion
2. Deletion
3. Display stack contents
4. Exit
Enter your choice :  4

1. Integer Stack
2. Float Stack
3. Character Stack
4. Exit
Enter your choice :  4
int x: typeid(x).name() = int typeid(int).name() = int
float y: typeid(y).name() = float typeid(float).name() = float
char z: typeid(z).name() = char typeid(char).name() = char
Press any key to continue

/*
Program 10 : Write a C Program to implement the integer stack through linked lists. 
	Note: Stacks
		A Stack is a data structure in which data is organised in a LIFO form.
LIFO means Last In First Out. Stacks have the same entry and exit points.
push : The process of storing the data into the stack is called push.
pop : The process of retrieving the data from the stack is called pop.

	A stack has a pointer called stack pointer which always points to the top most 
element of the stack. Stacks are used by the operating system to allocate memory
for local variables.
*/

// Implementation of stacks through linked lists.

#include <stdio.h>
#include <malloc.h>
#include <process.h>	// exit()

struct tt
{
	struct tt* early;
	int n;
};

void main()
{
	struct tt*  sp;
	int i, sz, num, res;

	void push(struct tt**, int);	// function prototype
	int  pop(struct tt**);

	sp = NULL;

	printf("\nEnter no.of values to store in a stack :  ");
	scanf("%d",&sz);

	for(i=0; i<sz; i++)
	{
		printf("Enter value %d :  ", i+1);
		scanf("%d",&num);
		push(&sp, num);
	}

	printf("\nRetrieving/Displaying the contents of the stack\n");
	for(i=0; i<sz; i++)
	{
		res = pop(&sp);
		printf("%d\t",res);
	}
	printf("\n");
}

void push(struct tt** pp, int num)
{
	struct tt *pnew;
	pnew = (struct tt*)malloc(sizeof(struct tt));
	pnew->n = num;
	pnew->early = *pp;
	*pp = pnew;
}

int pop(struct tt** pp)
{
	int res;
	struct tt* pts;
	if(*pp == NULL)
	{
		printf("\nStack is empty");
		exit(0);
	}
	pts = *pp;
	res = pts->n;
	*pp = pts->early;
	free(pts);
	return res;
}
Output :

Enter no.of values to store in a stack :  5
Enter value 1 :  10
Enter value 2 :  20
Enter value 3 :  30
Enter value 4 :  40
Enter value 5 :  50

Retrieving/Displaying the contents of the stack
50      40      30      20      10
Press any key to continue

/*
Program 11 :	Write a C++ program for a queue class. It contains :
			Array s, variables F, R,  insert(), del(), display(), initialize().
			Note : Queue is nothing but FIFO(First In First Out).
			F contains the position/index of the first element inserted.
			R contains the position/index of the last element inserted.
				In Queues, insertion is from rear end i.e., RHS and deletion is
			from front end i.e., LHS.
			For insertion, do R++ . For deletion, do F++ .
			Condition for Queue empty is : R = -1.
			Whenever R = (size-1), Queue is full and insertion is not possible.
				When ther is only one element in the queue (F==R), to delete that
			element, do not perform F++. Instead reinitialize F=0 and R=-1.
				For implementing stacks, we require one Array, one variable.
				For implementing queues, we require one Array, two variables.
			Note : Stack insertion and Queue insertion methods are same whereas 
				Stack Deletion and Queue Deletion methods are different.
*/

#include <iostream.h>
#include <conio.h>		// getch()

// #define size 10
const int size = 10;

class queue
{
private:
	int Q[size];
	int F, R;
public:
	void initialize();
	void insert(int x);
	int del();
	void display();
};

void queue::initialize()
{
	F = 0;
	R = -1;
}

void queue::insert(int x)
{
	if(R == size-1)
		cout << "\nQueue is full. Insertion is not possible" << endl;
	else
	{
		R++;
		Q[R] = x;
	}
}

int queue::del()
{
	int x;
	if(R == -1)		// no element
		return (-1);
	if(F == R)	// one element
	{
		x = Q[F];	// x = Q[R];
		initialize();
		return(x);
	}
	else	// more than one element
	{
		x = Q[F];
		F++;
		return(x);
	}
}

void queue::display()
{
	if(R == -1)
		cout << "\nQueue is empty" << endl;
	else

	{
		for(int i=F; i<=R; i++)
			cout << Q[i] << "\t";
		cout << endl;
	}
}

void menu()
{
	cout << "\n1. Insertion";
	cout << "\n2. Deletion";
	cout << "\n3. Display Queue Contents";
	cout << "\n4. Exit" << endl;
}

main()
{
	int ch, x;
	void menu();	// function prototype, optional

	queue a;
	a.initialize();
	
	menu();
	cout << "\nEnter your choice :  ";
	cin >> ch;

	while(ch < 4)
	{
		switch(ch)
		{
		case 1:		// Inserting an element into the queue
			{
				cout << "\nEnter the integer number to be inserted into the queue :  ";
				cin >> x;
				a.insert(x);
				break;
			}
		case 2:		// Deleting an element from the queue
			{
				x = a.del();	// x contains either -1 or deleted element
				if(x == -1)
					cout << "\nQueue is Empty. Deletion is not possible" << endl;
				else
					cout << "\nDeleted element is " << x << endl;
				break;
			}
		case 3:		// Displaying the queue contents
			{
				a.display();
				break;
			}
		default:
			{
				cout << "\nInvalid choice" << endl;
				break;
			}
		}	// switch match
		
		menu();
		cout << "\nEnter your choice :  ";
		cin >> ch;
	}	// while match

	cout << endl;
	
	getch();
	return(0);
}	// main() match

Output :

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  3

Queue is empty

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  2

Queue is Empty. Deletion is not possible

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  1

Enter the integer number to be inserted into the queue :  15

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  1

Enter the integer number to be inserted into the queue :  25

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  1

Enter the integer number to be inserted into the queue :  35

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  3
15      25      35

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  2

Deleted element is 15

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  2

Deleted element is 25

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  3
35

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  2

Deleted element is 35

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  3

Queue is empty

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  2

Queue is Empty. Deletion is not possible

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit

Enter your choice :  4

Press any key to continue

/*
Program 12 : Write a C++ program for a generic queue class.
	Note: 
	1. If the member functions are defined outside the generic class, then
		before each member function, we should write
		template<class T>.
		This is not required if the member functions are defined within
		the generic class.
	2. The generic queue class name is queue<T>. If it is normal classs, class
		name is queue.
	3. In Generic function, atleast one formal parameter must be of type T. In
		Generic class, atleast one class variable must be generic type T.
	4. Generic functions should be preceded by 
		template<class T>.
			There are two rules for generic functions.
			(1). It must be written before the calling function i.e. main();
			(2). It can not have prototypes.

*/

#include <iostream.h>
#include <typeinfo.h>

// #define size 10
const int size = 10;

template < class T >
class queue
{
private:
	T Q[size];
	int F, R;
public:
	void initialize();
	void insert(T x);
	T del();
	void display();
};

template<class T>
void queue<T>::initialize()
{
	F = 0;
	R = -1;
}

template<class T>
void queue<T>::insert(T x)
{
	if(R == size-1)
		cout << "\nQueue is full. Insertion is not possible" << endl;
	else
	{
		R++;
		Q[R] = x;
	}
}

template<class T>
T queue<T>::del()
{
	T x;
	if(R == -1)
		return(-1);
	else if(F == R)
	{
		x = Q[F];	// x = Q[R];
		initialize();
		// (*this).initialize();
		// this->initialize();
		return (x);
	}
	else
	{
		x = Q[F];
		F++;
		return(x);
	}
}

template<class T>
void queue<T>::display()
{
	int i;
	if(R == -1)
		cout << "\nQueue is Empty." << endl;
	else
	{
		for(i=F; i<=R; i++)
			cout << Q[i] << "\t";
		cout << '\n';
	}
}

void menu1()
{
	cout << "\n1. Integer Queue";
	cout << "\n2. Float Queue";
	cout << "\n3. Character Queue";
	cout << "\n4. Exit";
}

void menu2()
{
	cout << "\n1. Insertion";
	cout << "\n2. Deletion";
	cout << "\n3. Display Queue Contents";
	cout << "\n4. Exit";
}

// Generic function to perform the operations on Queue objects
template<class T>
void operation(queue<T> a)
{
	int ch;
	T x;

	menu2();
	cout << "\nEnter your choice :  ";
	cin >> ch;

	while(ch < 4)
	{
		switch(ch)
		{
		case 1:		// Inserting the element into the queue
			{
				if(typeid(x) == typeid(int))
					cout << "\nEnter the Integer number to be inserted into the queue :  ";
				else if(typeid(x) == typeid(float))
					cout << "\nEnter the Float number to be inserted into the queue :  ";
				else if(typeid(x) == typeid(char))
					cout << "\nEnter the character to be inserted into the queue :  ";

				cin >> x;
				a.insert(x);

				break;
			}
		case 2:		// Deleting the element from the queue
			{
				x = a.del();
				if(x == -1)
					cout << "\nQueue is Empty. Deletion is not possible." << endl;
				else
				{
					cout << "\nDeleted element is :  " << x << endl;
				}
				break;
			}
		case 3:		// Displaying the Queue contents
			{
				a.display();
				break;
			}
		default:
			{
				cout << "\nInvalid choice" << endl;
				break;
			}
		}	// switch match

		menu2();
		cout << "\nEnter your choice :  ";
		cin >> ch;
	}	// while match
}	// operation() match

main()
{
	int ch;

	void menu1();		// function prototype, optional

	menu1();
	cout << "\nEnter your choice :  ";
	cin >> ch;

	while(ch < 4)
	{
		switch(ch)
		{
		case 1:		// Integer queue
			{
				queue<int> a;
				a.initialize();
				operation(a);
				break;
			}
		case 2:		// Float queue
			{
				queue<float> a;
				a.initialize();
				operation(a);
				break;
			}
		case 3:		// character queue
			{
				queue<char> a;
				a.initialize();
				operation(a);
				break;
			}
		default:
			{
				cout << "\nInvalid choice." << endl;
				break;
			}
		}	// switch match

		menu1();
		cout << "\nEnter your choice :  ";
		cin >> ch;
	}	// while match

	cout << endl;
	return(0);
}

Output :

1. Integer Queue
2. Float Queue
3. Character Queue
4. Exit
Enter your choice :  3

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  1

Enter the character to be inserted into the queue :  t

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  1

Enter the character to be inserted into the queue :  p

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  3
t       p

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  2

Deleted element is :  t

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  3
p

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  2

Deleted element is :  p

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  3

Queue is Empty.

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  4

1. Integer Queue
2. Float Queue
3. Character Queue
4. Exit
Enter your choice :  1

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  1

Enter the Integer number to be inserted into the queue :  -124

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  1

Enter the Integer number to be inserted into the queue :  251

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  3
-124    251

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  2

Deleted element is :  -124

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  2

Deleted element is :  251

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  3

Queue is Empty.

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  4

1. Integer Queue
2. Float Queue
3. Character Queue
4. Exit
Enter your choice :  2

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  1

Enter the Float number to be inserted into the queue :  23.251

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  1

Enter the Float number to be inserted into the queue :  95.2541

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  3
23.251  95.2541

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  2

Deleted element is :  23.251

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  3
95.2541

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  2

Deleted element is :  95.2541

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  3

Queue is Empty.

1. Insertion
2. Deletion
3. Display Queue Contents
4. Exit
Enter your choice :  4

1. Integer Queue
2. Float Queue
3. Character Queue
4. Exit
Enter your choice :  4

Press any key to continue

/*
Program 13 : Write a C Program to implement queues through linked lists.
		Note: Queues 
			Queue is a data structure in which data is arranged in FIFO manner.
		FIFO means First In First Out. Queues have a separate entry point and exit 				points. Queues are used by the operating systems to schedule the tasks that are 		to be submitted to the CPU.
*/

#include <stdio.h>
#include <process.h>	// exit()
#include <malloc.h>

struct tt
{
	int n;
	struct tt *next;
}

main()
{
	struct tt *first, *last;
	int i, sz, num, res;
	char ch = 'y';

	void enter(struct tt**, struct tt**, int);	// function prototype
	int disp(struct tt**);

	first = last = NULL;
	do
	{
		if(ch == 'y')
			printf("\nEnter the no.of values to store in a queue(max. 20) : ");
		else
		{
			printf("\n%d is Invalid Input.", sz);
			printf("\nEnter the valid no.of values to store in a queue (between 1 to 20 only) :  ");
		}
		scanf("%d",&sz);
		if(sz<=0 || sz>20)
			ch='n';
	}while(sz<=0 || sz>20);

	for(i=0; i<sz; i++)
	{
		printf("Enter value %d :  ",i+1);
		scanf("%d",&num);
		enter(&first, &last, num);
	}
	/*
	// To make circular queue, add the following statement.
	last->next = first;
	*/

	printf("\nRetrieving the contents of a queue\n");
	for(i=0; i<=sz; i++)
	{
		res = disp(&first);
		printf("%d\t", res);
	}
	printf("\n");
}

// Entering data to a queue
void enter(struct tt **fst, struct tt **lst, int num)
{
	struct tt *pnew;
	pnew = (struct tt*)malloc(sizeof(struct tt));
	
	pnew->n = num;
	pnew->next = NULL;

	if(*fst == NULL)
		*fst = pnew;
	else
		(*lst)->next = pnew;

	*lst = pnew;
}

// Displaying the contents from the queue
int disp(struct tt **fst)
{
	int res;
	struct tt* pts;

	if(*fst == NULL)
	{
		printf("\nQueue is Empty.\n");
		exit(0);
	}

	pts = *fst;
	res = pts->n;
	*fst = pts->next;
	
	return (res);
}

Output :

Enter the no.of values to store in a queue(max. 20) : -5

-5 is Invalid Input.
Enter the valid no.of values to store in a queue (between 1 to 20 only) :  5
Enter value 1 :  12
Enter value 2 :  23
Enter value 3 :  -25
Enter value 4 :  65
Enter value 5 :  -958

Retrieving the contents of a queue
12      23      -25     65      -958
Queue is Empty.
Press any key to continue

/*
Program 14 : Write a C++ program to implement the Linked List 
*/

#include <iostream.h>
#include <stdio.h>
#include <conio.h>		// getch()

struct node
{
	int data;
	node* link;		// self-referential structure
};

class linklist
{
private:
	node* first;
public:
	void create();
	void display();
	int length();

	void insertafter(int i, int x);
	void insertbefore(int i, int x);
	int del(int i);
};

void linklist::create()
{
	node* previous, *present, *k;
	int x;
	this->first = new node;
	previous = first;

	cout << "\nEnter data(Integer value) of all nodes, terminated by -1\n";
	cin >> x;

	while(x != -1)
	{
		present = new node;
		present->data = x;
		previous->link = present;
		previous = present;
		cin >> x;
	}
	previous->link = NULL;
	k = first;
	first = first->link;
	delete k;
}

void linklist::display()
{
	node* temp;
	if(this->first == NULL)
		cout << "\nLinked List is Empty" << endl;
	else
	{
		temp = first;
		while(temp != NULL)
		{
			cout << temp->data << "\t" << temp->link << endl;
			temp = temp->link;
		}
	}
}

int linklist::length()
{
	int counter = 0;
	node* temp;

	temp = this->first;
	while(temp != NULL)
	{
		counter++;
		temp = temp->link;
	}
	return counter;
}

void linklist::insertafter(int i, int x)
{
	int j;
	node *p, *temp;
	p = new node;
	p->data = x;
	temp = first;

	for(j=1; j<i; j++)
		temp = temp->link;
	p->link = temp->link;
	temp->link = p;
}

void linklist::insertbefore(int i, int x)
{
	int j;
	node *previous, *present, *p;

	p = new node;
	p->data = x;

	if(i == 1)
	{
		p->link = first;
		first = p;
	}
	else
	{
		present = first;
		for(j=1; j<=i-1; j++)
		{
			previous = present;
			present = present->link;
		}
		previous->link = p;
		p->link = present;
	}
}

int linklist::del(int i)	// ith node should be deleted
{
	node *k, *previous, *present;
	int  j, x;
	
	if(i == 1)	// logic for deletion of 1st node
	{
		k = first;
		first = first->link;
		x = k->data;
		delete k;
		return (x);
	}
	else		// logic for deletion of middle and last node
	{
		present = first;
		for(j=1; j<=i-1; j++)
		{
			previous = present;
			present = present->link;
		}
		previous->link = present->link;
		x = present->data;
		delete present;
		return (x);
	}
}

void menu()
{
	cout << "\n1. Display the linked list";
	cout << "\n2. Length of the linked list";
	cout << "\n3. Insert a node after ith node";
	cout << "\n4. Insert a node before ith node";
	cout << "\n5. Delete a ith node";
	cout << "\n6. Exit" << endl;
}

main()
{
	int i, x, l, ch;

	void menu();		// function prototype

	linklist a;
	a.create();

	menu();
	cout << "\nEnter your choice :  ";
	cin >> ch;

	while(ch < 6)
	{
		switch(ch)
		{
		case 1:		// Displaying the linked list
			{
				a.display();
				break;
			}
		case 2:		// Length of the linked list
			{
				l = a.length();
				cout << "\nLength of the linked list is :  " << l << endl;
				break;
			}
		case 3:		// Inserting a node after ith node
			{
				cout << "\nEnter i value :  ";
				cin >> i;
				l = a.length();
				if(i > l)
					cout << "\nInvalid node number" << endl;
				else
				{
					cout << "\nEnter the data of new node :  ";
					cin >> x;
					a.insertafter(i, x);
					cout << "\nNode is inserted" << endl;
				}
				break;
			}
		case 4:		// Inserting a node before ith node
			{
				cout << "\nEnter i value :  ";
				cin >> i;
				l = a.length();
				if(i > l)
				{
					cout << "\nInvalid node number" << endl;
				}
				else
				{
					cout << "\nEnter the data of new node :  ";
					cin >> x;
					a.insertbefore(i, x);
					cout << "\nNode is inserted" << endl;
				}
				break;
			}
		case 5:		// Deleting the ith node
			{
				cout << "\nEnter i value :  ";
				cin >> i;
				l = a.length();
				if(i > l)
				{
					cout << "\nInvalid node number " << endl;
				}
				else
				{
					x = a.del(i);
					cout << "\nData of the deleted node is :  " << x << endl;
				}
				break;
			}
		default:
			{
				cout << "\nInvalid choice" << endl;
				break;
			}
		}	// switch match

		menu();
		cout << "\nEnter your choice :  ";
		cin >> ch;
	}	// while match

	cout << endl;
	getch();
	return(0);
}
Output :
6. Exit

Enter your choice :  4

Enter i value :  1

Enter the data of new node :  15

Node is inserted

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  1
15      0x002F2FC8
10      0x002F1200
20      0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  3

Enter i value :  2

Enter the data of new node :  100

Node is inserted

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  1
15      0x002F2FC8
10      0x002F1238
100     0x002F1200
20      0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  4

Enter i value :  4

Enter the data of new node :  555

Node is inserted

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  1
15      0x002F2FC8
10      0x002F1238
100     0x002F1270
555     0x002F1200
20      0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  5

Enter i value :  3

Data of the deleted node is :  100

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  1
15      0x002F2FC8
10      0x002F1270
555     0x002F1200
20      0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  4

Enter i value :  3

Enter the data of new node :  444

Node is inserted

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  1
15      0x002F2FC8
10      0x002F1238
444     0x002F1270
555     0x002F1200
20      0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  4

Enter i value :  3

Enter the data of new node :  333

Node is inserted

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  1
15      0x002F2FC8
10      0x002F12A8
333     0x002F1238
444     0x002F1270
555     0x002F1200
20      0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  3

Enter i value :  2

Enter the data of new node :  222

Node is inserted

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  1
15      0x002F2FC8
10      0x002F12E0
222     0x002F12A8
333     0x002F1238
444     0x002F1270
555     0x002F1200
20      0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  3

Enter i value :  6

Enter the data of new node :  666

Node is inserted

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  1
15      0x002F2FC8
10      0x002F12E0
222     0x002F12A8
333     0x002F1238
444     0x002F1270
555     0x002F1318
666     0x002F1200
20      0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  3

Enter i value :  2

Enter the data of new node :  111

Node is inserted

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  1
15      0x002F2FC8
10      0x002F1350
111     0x002F12E0
222     0x002F12A8
333     0x002F1238
444     0x002F1270
555     0x002F1318
666     0x002F1200
20      0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  5

Enter i value :  2

Data of the deleted node is :  10

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  1
15      0x002F1350
111     0x002F12E0
222     0x002F12A8
333     0x002F1238
444     0x002F1270
555     0x002F1318
666     0x002F1200
20      0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete a ith node
6. Exit

Enter your choice :  6

Press any key to continue

/*
Program 15 : Write a C++ Program to implement the Generic Linked List.
*/

#include <iostream.h>
#include <typeinfo.h>

template <class T>
class linklist
{
private:
	struct node
	{
		T data;
		node* link;
	}*first;
public:
	void create();
	void display();
	int length();

	void insertafter(int i, T x);
	void insertbefore(int i, T x);
	T del(int i);
};

template<class T>
void linklist<T>::create()
{
	node *previous, *present, *k;
	T x;
	previous = this->first = new node;
	
	if(typeid(x) == typeid(int))
		cout << "\nEnter integer data of all nodes. Terminate by -1" << endl;
	else if(typeid(x) == typeid(float))
		cout << "\nEnter float data of all nodes. Terminate by -1 " << endl;
	else if(typeid(x) == typeid(char))
		cout << "\nEnter char data of all nodes. Terminate by ! " << endl;

	cin >> x;	// accepts 1st node data
	while( (x  != -1) && (x != '!'))
	{
		present = new node;		// actual node is created
		present->data = x;
		previous->link = present;
		previous = present;
		cin.get();
		cin >> x;
	}
	previous->link = NULL;
	k = first;
	first = first->link;
	delete k;
}

template<class T>
void linklist<T>::display()
{
	node *temp;
	if(this->first == NULL)
		cout << "\nLinked List is Empty" << endl;
	else
	{
		temp = first;
		while(temp != NULL)
		{
			cout << temp->data << "\t" << temp->link << "\n";
			temp = temp->link;
		}
	}
}

template<class T>
int linklist<T>::length()
{
	int counter = 0;
	node *temp = first;

	while(temp != 0)	// while(temp != NULL)
	{
		counter++;
		temp = temp->link;
	}
	return counter;
}

template<class T>
void linklist<T>::insertafter(int i, T x)
{
	int j;
	node *p, *temp;
	p = new node;
	p->data = x;
	temp = this->first;
	for(j=1; j<i;  j++)
		temp = temp->link;
	p->link = temp->link;
	temp->link = p;
}

template <class T>
void linklist<T>::insertbefore(int i, T x)
{
	int j;
	node *previous, *present, *p;
	
	p = new node;
	p->data = x;
	if(i == 1)
	{
		p->link = first;
		first = p;
	}
	else
	{
		present = first;
		for(j=1; j<i; j++)
		{
			previous = present;
			present = present->link;
		}
		previous->link = p;
		p->link = present;
	}
}

template<class T>
T linklist<T>::del(int i)
{
	T x;
	int j;
	node *k, *previous, *present;

	if(i == 1)
	{
		k = first;
		first = first->link;
		x = k->data;
		delete k;
		return x;
	}
	else
	{
		present = first;
		for(j=1; j<i; j++)
		{
			previous = present;
			present = present->link;
		}
		previous->link = present->link;
		x = present->data;
		delete present;
		return (x);
	}
}

void menu1()
{
	cout << "\n1. Integer Linked List";
	cout << "\n2. Float Linked List";
	cout << "\n3. Character Linked List" << endl;
}
void menu2()
{
	cout << "\n1. Display the linked list";
	cout << "\n2. Length of the linked list";
	cout << "\n3. Insert a node after ith node";
	cout << "\n4. Insert a node before ith node";
	cout << "\n5. Delete ith node";
	cout << "\n6. Exit" << endl;
}

// Generic function
template<class T>
void operation(linklist<T> a)
{
	int ch, l, i;
	T x;

	menu2();
	cout << "\nEnter your choice :  ";
	cin >> ch;

	while(ch < 6)
	{
		switch(ch)
		{
		case 1:		// Display the linked list
			{
				a.display();
				break;
			}
		case 2:		// Length of the linked list
			{
				l = a.length();
				cout << "\nLength of the Linked List =  " << l << endl;
				break;
			}
		case 3:		// Insert a node after ith node
			{
				cout << "\nEnter i value after which node is inserted :  ";
				cin >> i;
				l = a.length();
				if(i > l)
					cout << "\nInvalid node number" << endl;
				else
				{
					cout << "\nEnter the data of new node :  ";
					cin >> x;
					a.insertafter(i, x);
					cout << "\nnode is inserted" << endl;	// feedback to user
				}
				break;
			}
		case 4:		// Insert a node before ith node
			{
				cout << "\nEnter i value before which new node is inserted :  ";
				cin >> i;
				l = a.length();
				if(i > l)
					cout << "\nInvalid node number" << endl;
				else
				{
					cout << "\nEnter the data of new node :  ";
					cin >> x;
					a.insertbefore(i, x);
					cout << "\nnode is inserted" << endl;
				}
				break;
			}
		case 5:		// Delete a ith node
			{
				cout << "\nEnter i value (node number) which is to be deleted :  ";
				cin >> i;
				l = a.length();
				if(i > l)
					cout << "\nInvalid node number" << endl;
				else
				{
					x = a.del(i);
					cout << "\nData of the deleted node is :  " << x << endl;
				}
				break;
			}
		default:
			{
				cout << "\nInvalid choice" << endl;
				break;
			}

		}	// switch match

		menu2();
		cout << "\nEnter your choice :  ";
		cin >> ch;
	}	// while match
}

main()
{
	int ch;
	
	menu1();
	cout << "\nEnter your choice :  ";
	cin >> ch;

	while(ch < 4)
	{
		switch(ch)
		{
		case 1:		// Integer linked list
			{
				linklist<int> a;
				a.create();
				operation(a);
				break;
			}
		case 2:		// Float linked list
			{
				linklist<float> a;
				a.create();
				operation(a);
				break;
			}
		case 3:		// Character linked list
			{
				linklist<char> a;
				a.create();
				operation(a);
				break;
			}
		default :
			{
				cout << "\nInvalid choice" << endl;
				break;
			}
		}	// switch match
		menu1();
		cout << "\nEnter your choice :  ";
		cin >> ch;
	}	// while match

	cout << endl;
	return(0);
}

Output :

1. Integer Linked List
2. Float Linked List
3. Character Linked List

Enter your choice :  3

Enter char data of all nodes. Terminate by !
p
k
!

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete ith node
6. Exit

Enter your choice :  1
p       0x002F1200
k       0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete ith node
6. Exit

Enter your choice :  5

Enter i value (node number) which is to be deleted :  2

Data of the deleted node is :  k

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete ith node
6. Exit

Enter your choice :  1
p       0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete ith node
6. Exit

Enter your choice :  6

1. Integer Linked List
2. Float Linked List
3. Character Linked List

Enter your choice :  2

Enter float data of all nodes. Terminate by -1
12.62
36.5412
-1

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete ith node
6. Exit

Enter your choice :  4

Enter i value before which new node is inserted :  2

Enter the data of new node :  55.55

node is inserted

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete ith node
6. Exit

Enter your choice :  1
12.62   0x002F2F90
55.55   0x002F1238
36.5412 0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete ith node
6. Exit

Enter your choice :  5

Enter i value (node number) which is to be deleted :  3

Data of the deleted node is :  36.5412

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete ith node
6. Exit

Enter your choice :  1
12.62   0x002F2F90
55.55   0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete ith node
6. Exit

Enter your choice :  6

1. Integer Linked List
2. Float Linked List
3. Character Linked List

Enter your choice :  1

Enter integer data of all nodes. Terminate by -1
10
30
-1

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete ith node
6. Exit

Enter your choice :  3

Enter i value after which node is inserted :  1

Enter the data of new node :  20

node is inserted

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete ith node
6. Exit

Enter your choice :  1
10      0x002F1238
20      0x002F12A8
30      0x00000000

1. Display the linked list
2. Length of the linked list
3. Insert a node after ith node
4. Insert a node before ith node
5. Delete ith node
6. Exit

Enter your choice :  6

1. Integer Linked List
2. Float Linked List
3. Character Linked List

Enter your choice :  4

Press any key to continue

